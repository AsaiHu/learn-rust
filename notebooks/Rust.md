## Rust



Rust 是一种 **预编译静态类型**（*ahead-of-time compiled*）语言，这意味着可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行，即脱离环境。

编译： rustc main.rs 

运行： ./main.exe



代码风格

函数和变量名使用 *snake case* 规范风格，即字母都小写并用下划线分隔



`main` 函数是一个特殊的函数，即主函数，是Rust程序的入口



`std`:标准库



`io`:输入输出库



`&` 表示这个参数是一个 **引用**（*reference*），它允许多处代码访问同一处数据，而无需在内存中多次拷贝。



println!中的{}会夹住合适的值来打印



变量：let 默认不可变，添加mut使其可变

常量：const 总是不可变，命名约定是单词使用全大写且之间加下划线

隐藏：可以在同一作用域内定义一个与之前变量同名的新变量，使之前的变量被隐藏，常用于改变值的类型



数据类型中的四种标量类型

整型：默认i32,整型溢出在debugger模式会编译报错，在release模式会表现为环，整数除法会向下舍入到最接近的整数

浮点数：默认f64

布尔型：用bool表示

字符型：用单引号声明 `char` 字面量，使用双引号声明字符串字面量



两种复合类型

元组：元素的类型可以不同，可以解构获得值，也可以使用下标索引直接访问

数组：元素的类型必须相同

vector：初步判断应该是实现了动态扩容和动态缩容



Rust 是一门基于表达式的语言，语句不返回值

表达式：函数调用，宏调用，if



if条件不用加括号，必须是bool值



有三种循环：`loop`、`while` 和 `for`

loop：重复执行代码，直到要求停止

在嵌套循环中，`break` 和 `continue` 应用于此时最内层的循环，或者使用循环标签，这样就会被作用于被标签的循环

break可以返回值，和return一样



while：和其他语言一样



for：用来遍历集合，for...in...

这样看，rust中的几个循环结构和js中还是有较大差异的



string的数据被存储在堆空间中，赋值拷贝时只拷贝其指针、长度和容量，被拷贝后原变量会无效，这样一个操作被称为 **移动**，这种方式还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 **自动** 的复制可以被认为对运行时性能影响较小。

rust还提供了一个叫做 `clone` 的通用函数，用来拷贝堆上的数据

drop：释放占用的内存

看了所有权这章后感觉这种设计真是太棒了，所有变量都可以清晰的被追踪



& 符号就是 **引用**，它们允许你使用值但不获取其所有权，**引用**（*reference*）像一个指针，因为它是一个地址，但与指针不同，引用确保指向某个特定类型的有效值，而不是像指针一样访问到不被预料到的值。

创建一个引用的行为称为 **借用**，无法通过引用修改原始值，但可以创建一个可变引用，可以修改可变引用来修改原始值，可以变量同一时间只能存在一个可变引用， **也** 不能在拥有不可变引用的同时拥有可变引用，但拥有多个不可变引用是可以的

Rust通过这种方式避免数据竞争，再次感慨，Rust太棒了！

悬垂指针是其指向的内存可能已经被分配给其它持有者，rust确保引用永远也不会变成悬垂状态



**字符串 slice**（*string slice*）是 `String` 中一部分值的引用，采用range语法，`starting_index` 是 slice 的第一个位置，`ending_index` 则是 slice 最后一个位置的后一个值

字符串字面值就是 slice，这也就是为什么字符串字面值是不可变的；`&str` 是一个不可变引用。