## Rust



Rust 是一种 **预编译静态类型**（*ahead-of-time compiled*）语言，这意味着可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行，即脱离环境。

编译： rustc main.rs 

运行： ./main.exe



#### 代码风格

函数和变量名使用 *snake case* 规范风格，即字母都小写并用下划线分隔



#### 基础



`main` 函数是一个特殊的函数，即主函数，是Rust程序的入口



`std`:标准库



`io`:输入输出库



`&` 表示这个参数是一个 **引用**（*reference*），它允许多处代码访问同一处数据，而无需在内存中多次拷贝。



println!中的{}会夹住合适的值来打印



#### 数据类型



变量：let 默认不可变，添加mut使其可变

常量：const 总是不可变，命名约定是单词使用全大写且之间加下划线

隐藏：可以在同一作用域内定义一个与之前变量同名的新变量，使之前的变量被隐藏，常用于改变值的类型



数据类型中的四种标量类型

整型：默认i32,整型溢出在debugger模式会编译报错，在release模式会表现为环，整数除法会向下舍入到最接近的整数

浮点数：默认f64

布尔型：用bool表示

字符型：用单引号声明 `char` 字面量，使用双引号声明字符串字面量



两种复合类型

元组：元素的类型可以不同，可以解构获得值，也可以使用下标索引直接访问

数组：元素的类型必须相同

vector：初步判断应该是实现了动态扩容和动态缩容



#### 函数



Rust 是一门基于表达式的语言，语句不返回值

表达式：函数调用，宏调用，if



#### 控制流



if条件不用加括号，必须是bool值



有三种循环：`loop`、`while` 和 `for`

loop：重复执行代码，直到要求停止

在嵌套循环中，`break` 和 `continue` 应用于此时最内层的循环，或者使用循环标签，这样就会被作用于被标签的循环

break可以返回值，和return一样



while：和其他语言一样



for：用来遍历集合，for...in...

这样看，rust中的几个循环结构和js中还是有较大差异的



#### 所有权



string的数据被存储在堆空间中，赋值拷贝时只拷贝其指针、长度和容量，被拷贝后原变量会无效，这样一个操作被称为 **移动**，这种方式还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 **自动** 的复制可以被认为对运行时性能影响较小。

rust还提供了一个叫做 `clone` 的通用函数，用来拷贝堆上的数据

drop：释放占用的内存

看了所有权这章后感觉这种设计真是太棒了，所有变量都可以清晰的被追踪



& 符号就是 **引用**，它们允许你使用值但不获取其所有权，**引用**（*reference*）像一个指针，因为它是一个地址，但与指针不同，引用确保指向某个特定类型的有效值，而不是像指针一样访问到不被预料到的值。

创建一个引用的行为称为 **借用**，无法通过引用修改原始值，但可以创建一个可变引用，可以修改可变引用来修改原始值，可以变量同一时间只能存在一个可变引用， **也** 不能在拥有不可变引用的同时拥有可变引用，但拥有多个不可变引用是可以的

Rust通过这种方式避免数据竞争，再次感慨，Rust太棒了！

悬垂指针是其指向的内存可能已经被分配给其它持有者，rust确保引用永远也不会变成悬垂状态



**字符串 slice**（*string slice*）是 `String` 中一部分值的引用，采用range语法，`starting_index` 是 slice 的第一个位置，`ending_index` 则是 slice 最后一个位置的后一个值

字符串字面值就是 slice，这也就是为什么字符串字面值是不可变的；`&str` 是一个不可变引用。



#### 结构体



struct的**字段初始化简写语法**有点类似js中对象的属性简写

**结构体更新语法**：就是把上个实例的部分值直接赋值给当前实例嘛，但如果更新中发生了移动，上个实例就无法再被使用了



**元组结构体**：用来给元组取名

每一个结构体有其自己的类型，即使结构体中的字段有着相同的类型



`dbg!` 宏接收一个表达式的所有权，打印出代码中调用 dbg! 宏时所在的文件和行号，以及该表达式的结果值，并返回该值的所有权



方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文），并且它们第一个参数总是 `self`，它代表调用该方法的结构体实例。



不是方法的关联函数经常被用作返回一个结构体新实例的构造函数

在 `impl` 块中，可以定义方法和函数



#### 枚举



枚举允许你通过列举可能的 **成员**（*variants*） 来定义一个类型，以此提供一个更宽泛的结构

在rust中，**空值**（*Null* ）是一个值，它代表没有值

match必须是穷尽的，对于未匹配的值，可以使用通配模式来解决

`if let` 是 `match` 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值。



#### 包，crate和模块



模块，是以 `mod` 关键字为起始，在模块内还可以定义其他的模块

路径有两种形式：

- **绝对路径**（*absolute path*）从 crate 根开始，以 crate 名或者字面值 `crate` 开头。
- **相对路径**（*relative path*）从当前模块开始，以 `self`、`super` 或当前模块的标识符开头。

绝对路径和相对路径都后跟一个或多个由双冒号（`::`）分割的标识符

要倾向于使用绝对路径，因为把代码定义和项调用各自独立地移动是常见的。

Rust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的。父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用他们父模块中的项。

用 `super` 开头来构建从父模块开始的相对路径

在一个结构体定义的前面使用了 `pub` ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的。

将枚举设为公有，则它的所有成员都将变为公有。

在作用域中增加 `use` 和路径类似于在文件系统中创建软连接

使用 `as` 指定一个新的本地名称或者别名，就像js中import的as那样

 “*重导出*（*re-exporting*）”：将 `pub` 和 `use` 合起来使用

嵌套路径可以消除大量的 use 行

 glob 运算符可以将所有的公有定义引入作用域，要谨慎使用

将模块移动到同名文件中，并在库文件中声明，就是模块拆分



#### 集合



*vector* 允许我们一个挨着一个地储存一系列数量可变的值，感觉就是数组，单行矩阵哈哈哈哈哈哈？？？？

`&` 和 `[]` 返回一个引用，当引用一个不存在的元素时程序会发生报错

用 `get` 方法以索引作为参数来返回一个 `Option<&T>`，如果不存在则返回None



*字符串*（*string*）是字符的集合。

字符串的两种创建方法：'aaa'.to_string()和String::from('aaa')

 `format!` 宏，返回一个带有结果内容的 `String`，不会获取任何参数的所有权

 Rust 不允许使用索引获取 `String` 字符

有一说一，rust的string设计的着实复杂，不过莫名觉得合理哈哈



**哈希 map**（*hash map*）允许我们将值与一个特定的键（key）相关联。这是一个叫做 *map* 的更通用的数据结构的特定实现。

哈希 map 是同质的：所有的键必须是相同类型，值也必须都是相同类型。

`zip` 方法可以创建一个元组的迭代器

`Entry` 的 `or_insert` 方法在键对应的值存在时就返回这个值的可变引用，如果不存在则将参数作为新值插入并返回新值的可变引用

`HashMap` 默认使用一种叫做 SipHash 的哈希函数，它可以抵御涉及哈希表的DoS攻击



#### 错误处理



Rust 将错误分为两大类：**可恢复的**和 **不可恢复的**错误。

 `panic!`宏。当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出

panic = 'abort'，直接终止，由操作系统来清理内存

*backtrace* 是一个执行到目前位置所有被调用的函数的列表

`unwrap`：打开，如果 `Result` 值是成员 `Ok`，`unwrap` 会返回 `Ok` 中的值。如果 `Result` 是成员 `Err`，`unwrap` 会为我们调用 `panic!`

`expect`:在`unwarp`基础上自己指定错误信息

**传播**（*propagating*）错误：让调用者知道这个错误并决定该如何处理，简写：`?` 运算符，只能被用于返回值与 `?` 作用的值相兼容的函数，`?` 也可用于 `Option<T>` 值

对任何错误场景都调用 `panic!`，不管是否有可能恢复，这样就是代替调用者决定了这是不可恢复的。选择返回 `Result` 值的话，就将选择权交给了调用者，而不是代替他们做出决定













